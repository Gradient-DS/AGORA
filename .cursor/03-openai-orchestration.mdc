---
description: OpenAI-native orchestration using Agents SDK
globs: server-openai/**/*
alwaysApply: false
---

# OpenAI Agents SDK Orchestration Architecture

**Philosophy**: Leverage the `openai-agents` SDK for stateful multi-agent orchestration, handoffs, and automatic tool execution, with a local SQLite session store.

## Core Principles

1.  **Use OpenAI Agents SDK (`agents` package)** - Native support for multi-agent handoffs and tool loops.
2.  **Multi-Agent Handoffs** - Explicit transfer of control between specialized agents (General -> Specialist).
3.  **SQLite Session Management** - Local, persistent conversation history stored in `sessions.db`.
4.  **Streaming First** - Real-time streaming of agent responses and tool events to the frontend.
5.  **MCP Integration** - Dynamic injection of MCP tools into agents based on their scope.

## Project Structure

```
server-openai/
├── src/
│   └── agora_openai/
│       ├── config.py              # Pydantic settings
│       ├── core/                  # Domain logic
│       │   ├── agent_definitions.py   # Agent configs & instructions
│       │   ├── agent_runner.py        # Agents SDK Wrapper (Runner)
│       │   └── approval_logic.py      # Human-in-loop rules
│       ├── adapters/              # External integrations
│       │   ├── mcp_tools.py           # MCP Tool Registry
│       │   └── audit_logger.py        # OpenTelemetry
│       ├── pipelines/             # Orchestration
│       │   ├── orchestrator.py        # Main flow coordinator
│       │   └── moderator.py           # Safety validation
│       └── api/                   # Entry point
│           ├── server.py              # FastAPI + WebSocket
│           └── hai_protocol.py        # HAI communication
```

## Agents SDK Integration

### Agent Definitions (`core/agent_definitions.py`)

Define agents with specific instructions, models, and handoff capabilities.

```python
from typing import TypedDict

class AgentConfig(TypedDict):
    id: str
    name: str
    instructions: str
    model: str
    tools: list[str]  # Built-in tool types (e.g. file_search)
    temperature: float
    handoffs: list[str] # IDs of agents this agent can transfer to

AGENT_CONFIGS = [
    {
        "id": "general-agent",
        "name": "NVWA General Assistant",
        "instructions": "...", # Includes instructions on WHEN to handoff
        "model": "gpt-4o",
        "handoffs": ["regulation-agent", "history-agent"],
        "tools": []
    },
    # ... other agents
]
```

### Agent Registry (`core/agent_runner.py`)

Manages agent instances and their MCP tool scope.

```python
# Mapping of agent IDs to MCP server names
AGENT_MCP_MAPPING = {
    "regulation-agent": ["regulation"],
    "history-agent": ["history"],
    # ...
}
```

### Agent Runner (`core/agent_runner.py`)

Wraps the `agents.Runner` to handle session persistence and streaming.

*   **Session Storage**: Uses `agents.SQLiteSession` with `sessions.db`.
*   **Streaming**: Uses `Runner.run_streamed()` to yield events.
*   **Handoff Detection**: Monitors tool calls for handoff events/tools.

## Orchestration Pipeline (`pipelines/orchestrator.py`)

Coordinates the flow between WebSocket/API and the Agent Runner.

1.  **Validation**: Checks input using `ModerationPipeline`.
2.  **Execution**: Calls `AgentRunner.run_agent()` (streaming or blocking).
3.  **Tool Approval**: Intercepts tool calls to check `approval_logic.requires_human_approval`.
4.  **Protocol Handling**: Converts Agent SDK events into HAI Protocol messages (`ToolCallMessage`, `AssistantMessageChunk`, etc.).

## Handoff Pattern

Instead of a central router determining the agent for every message, AGORA uses a **Handoff Pattern**:

1.  **Entry Point**: User starts with `general-agent`.
2.  **Detection**: The current agent's instructions guide it to call a handoff tool when a specific topic arises (e.g., "transfer_to_regulation_agent").
3.  **Transfer**: The Agent SDK handles the context switch.
4.  **Continuity**: The new agent receives the conversation history.

## Tool Approval Logic (`core/approval_logic.py`)

Defines high-risk operations requiring explicit user confirmation.

```python
HIGH_RISK_PATTERNS = ["delete", "submit_final", "publish"]

def requires_human_approval(tool_calls, context):
    # Returns (bool, reason, risk_level)
    # Pure logic, no I/O
```

## Best Practices

1.  **Instructions as Routing Logic**: Write clear instructions for agents on *when* to handoff.
2.  **Scope MCP Tools**: Only give agents the MCP tools they need (`AGENT_MCP_MAPPING`).
3.  **Stream Everything**: Use the `stream_callback` and `tool_callback` in `AgentRunner`.
4.  **Persist via SQLite**: Rely on `agents.SQLiteSession` for history.
5.  **Audit Logging**: Log all messages and tool calls to OpenTelemetry.

## HAI Protocol Mapping

The Orchestrator maps Agent SDK events to HAI Protocol:

*   `ResponseTextDeltaEvent` -> `AssistantMessageChunk`
*   `ToolCallItem` (started) -> `ToolCallMessage` (status='started')
*   `ToolCallOutputItem` -> `ToolCallMessage` (status='completed')
*   Handoff Events -> Logged / Status Updates

## Migration Note

This architecture replaces the previous custom Assistants API wrapper. It uses the official `openai-agents` library which provides built-in support for the multi-agent patterns we require.
